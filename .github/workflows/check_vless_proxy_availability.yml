name: Check VLESS proxy availability via Xray + HTTPS + Speed

on:
  workflow_dispatch:

jobs:
  check:
    runs-on: ubuntu-latest
    timeout-minutes: 60

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          persist-credentials: false

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y curl jq unzip python3 python3-pip
          pip3 install --upgrade pip

      - name: Download Xray
        run: |
          XRAY_VER=$(curl -s https://api.github.com/repos/XTLS/Xray-core/releases/latest | jq -r .tag_name)
          curl -L -o xray.zip https://github.com/XTLS/Xray-core/releases/download/${XRAY_VER}/Xray-linux-64.zip
          unzip -o xray.zip xray geoip.dat geosite.dat
          chmod +x xray

      - name: Prepare result files
        run: |
          mkdir -p githubmirror
          echo -n "" > githubmirror/26_proxy_alive.txt
          echo -n "" > githubmirror/26_proxy_ru_exit.txt
          echo -n "" > githubmirror/26_proxy_blocked_azure.txt

      - name: Get runner IP
        run: echo "RUNNER_IP=$(curl -s https://api.ipify.org)" >> $GITHUB_ENV

      - name: Check VLESS servers via Xray + HTTPS + Speed
        run: |
          python3 - <<'EOF'
          import subprocess, time, json, urllib.parse, urllib.request, os, threading
          from concurrent.futures import ThreadPoolExecutor, as_completed

          INPUT = "githubmirror/26_ru_whitelist.txt"
          RUNNER_IP = os.environ["RUNNER_IP"]
          PORT_BASE = 10800
          port_lock = threading.Lock()
          port_counter = 0

          def alloc_port():
              global port_counter
              with port_lock:
                  port_counter += 1
                  return PORT_BASE + port_counter

          TEST_URLS = [
              "https://api.ipify.org",
              "https://cloudflare.com/cdn-cgi/trace"
          ]

          def check_server(link):
              port = alloc_port()
              u = urllib.parse.urlparse(link)
              q = urllib.parse.parse_qs(u.query)
              stream = {"network": q.get("type", ["tcp"])[0]}
              sec = q.get("security", ["none"])[0]
              sni = q.get("sni", [""])[0]

              if sec == "tls" and sni:
                  stream["security"] = "tls"
                  stream["tlsSettings"] = {"serverName": sni}
              if sec == "reality" and "pbk" in q:
                  stream["security"] = "reality"
                  stream["realitySettings"] = {
                      "serverName": sni,
                      "publicKey": q["pbk"][0],
                      "shortId": q.get("sid", [""])[0]
                  }

              cfg = {
                  "inbounds": [{"port": port, "listen": "127.0.0.1", "protocol": "socks", "settings": {"udp": False}}],
                  "outbounds": [{
                      "protocol": "vless",
                      "settings": {"vnext": [{"address": u.hostname, "port": u.port or 443, "users": [{"id": u.username, "encryption": "none", "flow": q.get("flow", [""])[0]}]}]},
                      "streamSettings": stream
                  }]
              }

              cfg_path = f"cfg_{port}.json"
              with open(cfg_path, "w") as f:
                  json.dump(cfg, f)

              p = subprocess.Popen(["./xray", "run", "-c", cfg_path], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
              time.sleep(8)  # увеличиваем ожидание старта Xray

              def get_exit_ip():
                  for url in TEST_URLS:
                      try:
                          ip = subprocess.check_output(
                              ["curl","-4","-s","--max-time","8","-x",f"socks5h://127.0.0.1:{port}",url],
                              text=True
                          ).strip()
                          if ip:
                              return ip
                      except:
                          continue
                  return None

              def https_ok():
                  try:
                      out = subprocess.check_output(
                          ["curl","-4","-s","--max-time","5","-x",f"socks5h://127.0.0.1:{port}","https://cloudflare.com/cdn-cgi/trace"],
                          text=True
                      )
                      return "ip=" in out
                  except:
                      return False

              def speed_ok():
                  try:
                      r = subprocess.check_output(
                          ["curl","-4","-s","-L","-o","/dev/null","-w","%{speed_download}",
                           "-x",f"socks5h://127.0.0.1:{port}","--range","0-200000","--max-time","7",
                           "https://speed.cloudflare.com/__down"], text=True
                      )
                      return int(float(r)) >= 20_000  # порог снижен для CI/CD
                  except:
                      return False

              ip = get_exit_ip()
              p.terminate()
              time.sleep(1)

              if not ip or ip == RUNNER_IP:
                  return "blocked", link
              try:
                  with urllib.request.urlopen(f"https://ipapi.co/{ip}/country/") as r:
                      country = r.read().decode().strip()
              except:
                  country = "Unknown"

              if country == "RU":
                  return "ru_exit", link

              if https_ok() and speed_ok():
                  return "alive", link
              return "blocked", link

          with open(INPUT) as f:
              links = [l.strip() for l in f if l.strip().startswith("vless://")]

          results_alive = []
          results_ru = []
          results_blocked = []

          with ThreadPoolExecutor(max_workers=30) as exe:
              futures = [exe.submit(check_server, l) for l in links]
              for f in as_completed(futures):
                  status, link = f.result()
                  if status == "alive":
                      results_alive.append(link)
                      print("[OK]", link[:80])
                  elif status == "ru_exit":
                      results_ru.append(link)
                  else:
                      results_blocked.append(link)

          # Always overwrite
          with open("githubmirror/26_proxy_alive.txt","w") as f:
              for l in results_alive:
                  f.write(l+"\n")
          with open("githubmirror/26_proxy_ru_exit.txt","w") as f:
              for l in results_ru:
                  f.write(l+"\n")
          with open("githubmirror/26_proxy_blocked_azure.txt","w") as f:
              for l in results_blocked:
                  f.write(l+"\n")

          print("Finished. Alive:", len(results_alive), "RU exit:", len(results_ru), "Blocked:", len(results_blocked))
          EOF

      - name: Commit and push results
        env:
          GH_PAT: ${{ secrets.GH_PAT }}
        run: |
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"
          git add githubmirror/26_proxy_alive.txt \
                  githubmirror/26_proxy_ru_exit.txt \
                  githubmirror/26_proxy_blocked_azure.txt
          git commit --allow-empty -m "Proxy availability check via Xray + HTTPS + Speed"
          git push -f https://x-access-token:${GH_PAT}@github.com/${GITHUB_REPOSITORY} HEAD:main
