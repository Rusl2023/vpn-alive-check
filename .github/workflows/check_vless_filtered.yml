name: Check VLESS Servers (Reality + GeoIP, One per Country)

on:
  schedule:
    - cron: '*/9 * * * *'
  workflow_dispatch:

jobs:
  check:
    runs-on: ubuntu-latest

    steps:
      # 1️⃣ Checkout repository
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          persist-credentials: false

      # 2️⃣ Setup Python
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      # 3️⃣ Install dependencies
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests geoip2

      # 4️⃣ Check VLESS servers
      - name: Check VLESS servers (Reality, TCP latency, 1 per country)
        id: check_alive
        run: |
          python - <<'EOF'
          import os, time, socket, requests, urllib.parse, base64
          from concurrent.futures import ThreadPoolExecutor, as_completed
          import geoip2.database

          URLS = [
              "https://raw.githubusercontent.com/MatinGhanbari/v2ray-configs/main/subscriptions/v2ray/all_sub.txt",
              "https://raw.githubusercontent.com/AvenCores/goida-vpn-configs/refs/heads/main/githubmirror/26.txt",
              "https://raw.githubusercontent.com/ebrasha/free-v2ray-public-list/refs/heads/main/vless_configs.txt",
              "https://raw.githubusercontent.com/igareck/vpn-configs-for-russia/refs/heads/main/WHITE-SNI-RU-all.txt",
              "https://raw.githubusercontent.com/hamedcode/port-based-v2ray-configs/main/sub/vless.txt"
          ]

          TIMEOUT = 1.0
          MAX_LATENCY = 600
          CHECK_COUNT = 3
          DOUBLE_CHECKS = 2
          MAX_WORKERS = 150
          GEOIP_DB = "geoip/GeoLite2-Country.mmdb"

          reader = geoip2.database.Reader(GEOIP_DB)

          # ---------- load sources ----------
          lines = []

          for url in URLS:
              try:
                  r = requests.get(url, timeout=20)
                  r.raise_for_status()
                  lines.extend(r.text.splitlines())
                  print(f"[LOAD] {url}")
              except Exception as e:
                  print(f"[ERR] {url}: {e}")

          # ---------- decode base64 + collect vless ----------
          vless_list = []

          for l in lines:
              l = l.strip()
              if not l:
                  continue

              if l.startswith("vless://"):
                  vless_list.append(l)
                  continue

              try:
                  decoded = base64.b64decode(l).decode(errors="ignore")
                  for dl in decoded.splitlines():
                      if dl.startswith("vless://"):
                          vless_list.append(dl)
              except:
                  pass

          print(f"[INFO] total vless links: {len(vless_list)}")

          # ---------- helpers ----------
          def tcp_ping(host, port):
              try:
                  t = time.time()
                  s = socket.create_connection((host, port), timeout=TIMEOUT)
                  s.close()
                  return int((time.time() - t) * 1000)
              except:
                  return None

          def median(lst):
              lst = sorted(lst)
              return lst[len(lst)//2]

          def parse_vless(link):
              try:
                  u = urllib.parse.urlparse(link)
                  q = urllib.parse.parse_qs(u.query)
                  if q.get("security", [""])[0] != "reality":
                      return None, None
                  return u.hostname, u.port or 443
              except:
                  return None, None

          def country_of(host):
              try:
                  ip = socket.gethostbyname(host)
                  return reader.country(ip).country.iso_code or "unknown"
              except:
                  return "unknown"

          def check(link):
              host, port = parse_vless(link)
              if not host:
                  return None

              for _ in range(DOUBLE_CHECKS):
                  pings = []
                  for _ in range(CHECK_COUNT):
                      p = tcp_ping(host, port)
                      if p is None or p > MAX_LATENCY:
                          return None
                      pings.append(p)

              return median(pings), link, country_of(host)

          # ---------- check servers ----------
          best = {}

          with ThreadPoolExecutor(MAX_WORKERS) as ex:
              futures = [ex.submit(check, v) for v in vless_list]
              for f in as_completed(futures):
                  r = f.result()
                  if r:
                      med, link, country = r
                      if country not in best or med < best[country][0]:
                          best[country] = (med, link)
                          print(f"[OK] {country} {med} ms")

          results = sorted(best.values(), key=lambda x: x[0])

          # ---------- save ----------
          os.makedirs("githubmirror", exist_ok=True)

          plain = "githubmirror/26_alive.txt"
          b64 = "githubmirror/26_alive_base64.txt"

          with open(plain, "w") as f:
              for _, link in results:
                  f.write(link + "\n")

          with open(plain, "rb") as f:
              encoded = base64.b64encode(f.read()).decode()

          with open(b64, "w") as f:
              f.write(encoded)

          with open(os.environ["GITHUB_OUTPUT"], "a") as out:
              out.write(f"count={len(results)}\n")

          print(f"[DONE] alive servers: {len(results)}")
          EOF

      # 5️⃣ Commit & push
      - name: Commit and push result
        if: steps.check_alive.outputs.count != '0'
        run: |
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"

          git add githubmirror/26_alive.txt githubmirror/26_alive_base64.txt
          git commit --allow-empty -m "Update alive VLESS (Reality, 1 per country)"
          git push https://x-access-token:${{ secrets.GH_PAT }}@github.com/${{ github.repository }} HEAD:main
